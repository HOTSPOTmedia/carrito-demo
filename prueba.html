<!DOCTYPE html>
<html>
<head>
<!-- Add this to <head> -->

<!-- Load required Bootstrap and BootstrapVue CSS -->
<link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap/dist/css/bootstrap.min.css" />
<link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.css" />

<!-- Load polyfills to support older browsers -->
<script src="//polyfill.io/v3/polyfill.min.js?features=es2015%2CIntersectionObserver" crossorigin="anonymous"></script>

<!-- Load Vue followed by BootstrapVue -->
<script src="//unpkg.com/vue@latest/dist/vue.min.js"></script>
<script src="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.js"></script>

<!-- Load the following for BootstrapVueIcons support -->
<script src="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue-icons.min.js"></script>
	

<!-- libreria para el manejo del local store -->
<script src="https://unpkg.com/cart-localstorage@1.1.4/dist/cart-localstorage.min.js" type="text/javascript"></script>
<script src="https://code.jquery.com/jquery-3.3.1.js" integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60=" crossorigin="anonymous"></script>

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

</head>
  <body>


<div id='app'>
  <b-table :items="filteredItems">
    <template :slot="`HEAD_${ key }`" v-for="key in fieldKeys" slot-scope="data">
      <b>{{ data.label }}</b>
      <select class="form-control form-control-sm" @click.stop.prevent v-model="selectVal[key]">
			<option :value="undefined">--</option>
			<option :value="option" v-for="option in options[key]" :key="option">{{ option }}</option>
		</select>
    </template>
  </b-table>
</div>

<script>
new Vue({
  el: "#app",
  computed: {
    filteredItems() {
      return this.items.filter(item => {
        let keep = true;

        // This is a basic equality filter. What I did in the actual code was to have an object with filter functions for each key. If a key was missing, it defaulted to straight equality.
        this.fieldKeys.forEach(key => {
          keep =
          keep && (
          this.selectVal[key] === undefined ||
          item[key] === this.selectVal[key]);
        });

        return keep;
      });
    },
    fieldKeys() {
      return Object.keys(this.items[0]);
    },
    options() {
      // This could be simplified if the select was it's own component.
      const options = {};
      this.fieldKeys.forEach(key => {
        const vals = this.items.map(item => item[key]);

        // Cheap and efficient unique.
        options[key] = Array.from(new Set(vals));
      });

      return options;
    } },

  data: {
    items: [
    {
      isActive: true,
      age: 40,
      first_name: "Dickerson",
      last_name: "Macdonald" },

    {
      isActive: true,
      age: 42,
      first_name: "Robert",
      last_name: "Macdonald" },

    { isActive: false, age: 21, first_name: "Larsen", last_name: "Shaw" },
    { isActive: false, age: 89, first_name: "Geneva", last_name: "Wilson" },
    { isActive: true, age: 38, first_name: "Jami", last_name: "Carney" }],


    // This is much simpler if the select is it's own component.
    selectVal: {
      isActive: undefined,
      age: undefined,
      first_name: undefined,
      last_name: undefined } } });
</script>
	</body>
	
	</html>
